# Domain Repository

IDomainRepository is a DB-agnostic abstract repository layer over Node.JS ORM frameworks (Mongoose or TypeORM). You can think of it as simplified, but more strictly typed version of those.

Useful links:

- [Why use it? Benefits and FAQ](https://github.com/lukaszwilisowski/domain-repository/blob/main/DISCUSSION.md)
- [API (similar to TypeORM repository)](https://github.com/lukaszwilisowski/domain-repository/blob/main/API.md)
- [How to contribute?](https://github.com/lukaszwilisowski/domain-repository/CONTRIBUTION.MD)
- [Code example](https://github.com/lukaszwilisowski/domain-repository-example)

## Installation

1. If you are using Mongoose, or TypeORM, uninstall it.

```bash
npm uninstall mongoose mongodb typeorm @types/mongoose @types/mongodb @types/typeorm
```

2. Install domain-repository

```bash
npm install domain-repository
```

---

## How to use it

### 1. Define your domain models

Make sure you have domain models defined. Each model should be exported in two versions:

- default, `Detached` (without id), for objects not yet persisted in the database
- `Attached` (with id), for already persisted objects

This differentiation improves intellisense and debugging. You can call your models whatever you like, as long as you stick to your naming convention. Our recommendation is to add _Attached suffix_ to all of your attached models.

For example:

```typescript
export type Car = {
  name: string;
  best: boolean;
  readonly yearOfProduction: number;
  sold?: Date;
};

export type CarAttached = Car & { id: string };
```

An attached model will contain:

- a minimum string ID [(why string type?)](https://github.com/lukaszwilisowski/domain-repository/blob/main/DISCUSSION.md#6-why-object-id-should-be-of-type-string)
- other properties auto-generated by the db engine (not manually assignable)

---

### 2. Use IDomainRepository in your business services

Use `IDomainRepository`\* interface in places, where you would previously use Mongoose collection or TypeORM repository. Type it explicitly with your standard and Attached model type.

\*If you only need to read or write data you can also use narrowed versions of interfaces: `IReadDomainRepository` or `IWriteDomainRepository` (SOLID's Interface segregation principle).

```typescript
export class CarService {
  constructor(private readonly carRepository: IReadDomainRepository<CarAttached>) {}

  public async findBestCar(): Promise<CarAttached | undefined> {
    return this.carRepository.findOne({ best: true });
  }
}
```

---

### 3. Write unit tests (Test-driven-development)

First test your domain model and business service, using MockedDbRepository implementation.

```typescript
describe('CarService', () => {
  //simulate initial db data
  const initialData: CarAttached[] = [
    { id: '1', name: 'Volvo', best: false, yearOfProduction: 2000 },
    { id: '2', name: 'Toyota', best: true, yearOfProduction: 2010, sold: new Date() }
  ];

  //create mocked db repository (simulating db) with your initial data
  const mockedRepository = new MockedDBRepository<Car, CarAttached>(initialData);

  //pass the mocked implementation to your service constructor
  const carService = new CarService(mockedRepository);

  //test if your service works as expected
  it('should find best car', async () => {
    const car = await carService.findBestCar();

    expect(car).toBeDefined();
    expect(car!.name).toEqual('Toyota');
  });
});
```

---

### 4. Choose your DB technology and define model mappings.

Let's say I want to use MongoDB as my DB, and Mongoose as my ORM layer.

Let's create a new file for my DB model, for example: `car.entity.ts`:
Because we have mappings, this does not have to be the same model as domain model.

```typescript
export type CarEntity = {
  _id: mongoose.Types.ObjectId;
  name: string;
  best_of_all: boolean; //changed property name
  readonly yearOfProduction: number;
  sold?: Date;
};
```

Now create file `car.schema.ts` and define your db schema, using mongoose:

```typescript
const CarSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  best_of_all: {
    type: Boolean,
    required: true
  },
  yearOfProduction: {
    type: Number,
    required: true
  },
  sold: {
    type: Date,
    required: false
  }
});

//export function returing collection
export const getCarCollection = () => mongoose.model<CarEntity>('cars', CarSchema);
```

### 4. Supply your services with your repository implemenations for your target DB.

Only now, focus on your DB implementation. Defined your DB model and mapping between domain and DB model.
